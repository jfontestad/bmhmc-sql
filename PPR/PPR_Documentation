


> Written with [StackEdit](https://stackedit.io/).

Last updated on June 27th 2014 by Steven Sanderson

## Idea ##
Readmissions, specifically readmissions to a facility within 30 days is a measure set forth by The Centers for Medicare and Medicaid CMS as a metric of outcome quality. The idea is that if treated appropriately the first time a subsequent visit would be unnecessary. This can be a bit cumbersome as there are events that might not be clinically related to the initial visit, which is where looking at Potentially Preventable Readmissions is more appropriate. This then allows an institution to see if they are really providing quality care by limiting the amount of potentially preventable readmissions, those that are clinically related to the initial visit in some fashion.

This document lists the code and the meaning of it and is meant to be a working document of sorts.

There are three (3) Phases of the potentially preventable classification system, those being:

1. Phase 1 - Identify Excluded Admissions and Non-events
2. Phase 2 - Determine Preliminary Classification of Renaming Admissions
3. Phase 3 - Identify PPRs and Determine Final Classification of Admissions


----------


## Phase 1 ##
This phase deals with identifying those visits that are Globally-excluded admissions and non-events.

To do this we have created a table that lists globally-excluded APR-DRG's and Non-event DRG's, this table is not yet fully complete as non-event procedure codes are still missing from it, rather there is a query that creates a temp table of excluded procedure codes.

Create the Readmissions View (This is done)
Need to make it a table

    USE [SMSPHDSSS0X0]
    GO
    
    /****** 
    
    Object:  View [smsdss].[vReadmits]    Script Date: 06/30/2014 12:15:07 
    
    ******/
    
    SET ANSI_NULLS ON
    GO
    
    SET QUOTED_IDENTIFIER ON
    GO
    
    ALTER VIEW [smsdss].[vReadmits]
    AS
    WITH cte AS (
      SELECT Pt_No
      	, Med_Rec_No
    	, Dsch_Date
    	, Adm_Date
    	, ROW_NUMBER() OVER (
    	                     PARTITION BY MED_REC_NO 
    	                     ORDER BY ADM_DATE
    	                     ) AS r
    	                     
      FROM smsdss.BMH_PLM_PtAcct_V
      
      WHERE Plm_Pt_Acct_Type = 'I'
      AND PtNo_Num < '20000000' 
      )
    SELECT
    c1.Pt_No                                   AS [INDEX]
    , c2.Pt_No                                 AS [READMIT]
    , c1.Med_Rec_No                            AS [MRN]
    , c1.Dsch_Date                             AS [INITIAL DISCHARGE]
    , c2.Adm_Date                              AS [READMIT DATE]
    , DATEDIFF(DAY, c1.Dsch_Date, c2.Adm_Date) AS INTERIM
    , ROW_NUMBER() OVER (
    				    PARTITION BY C1.MED_REC_NO 
    				    ORDER BY C1.PT_NO
    				    ) AS [30D RA COUNT]
    
    FROM cte c1
    INNER JOIN cte c2 ON c1.Med_Rec_No = c2.Med_Rec_No
    
    WHERE c1.Adm_Date <> c2.Adm_Date
    AND c1.r+1 = c2.r

    GO

Code of the globally-excluded APR-DRGS (This is done)
This is already an indexed table

    /*
    VARIABLE DECLARATION AND INITIALIZATION
    */
    DECLARE @VISIT_ID VARCHAR(8);
    SET @VISIT_ID  = '20000000';
    
    /*
    #######################################################################
    
    CREATE AND POPULATE TABLE WITH GLOBALLY EXCLUDED APR-DRG'S
    
    #######################################################################
    */
    DECLARE @EXCLUSIONS TABLE (
    ID INT NOT NULL PRIMARY KEY,
    [APR-DRG] VARCHAR (3)
    )
    
    INSERT INTO @EXCLUSIONS(ID, [APR-DRG])
    VALUES
    -- GLOBAL EXCLUSIONS 
    (1,'041'),(2,'070'),(3,'073'),(4,'080'),(5,'082'),(6,'131'),(7,'580'),
    (8,'581'),(9,'583'),(10,'588'),(11,'589'),(12,'591'),(13,'593'),
    (14,'602'),(15,'603'),(16,'607'),(17,'608'),(18,'609'),(19,'611'),
    (20,'612'),(21,'613'),(22,'614'),(23,'621'),(24,'622'),(25,'623'),
    (26,'625'),(27,'626'),(28,'630'),(29,'631'),(30,'633'),(31,'634'),
    (32,'636'),(33,'639'),(34,'640'),(35,'690'),(36,'691'),(37,'692'),
    (38,'693'),(39,'694'),(40,'770'),(41,'890'),(42,'892'),(43,'893'),
    (44,'955'),(45,'956'),
    
    -- AGE EXCLUSION APR-DRG'S
    (46,'053'),(47,'248'),(48,'463'),(49,'812'),(50,'816'),
    
    -- TRUMA EXCLUSIONS
    (51,'308'),(52,'309'),
    (53,'384'),(54,'711'),(55,'910'),(56,'911'),(57,'912'),(58,'930'),
    
    -- NON-EVENT DRG'S
    (59,'110'),(60,'136'),(61,'240'),(62,'281'),(63,'343'),(64,'382'),
    (65,'442'),(66,'461'),(67,'500'),(68,'530'),(69,'680'),(70,'681'),
    (71,'860'),(72,'862'),(73,'863')
    ;
    
Now the code for excluded procedure codes: (This needs to be done)
The query is done but an indexed table needs to be made

    /*
    ########################################################################
    
    THIS QUERY WILL OBTAIN THOSE EVENTS THAT ARE NOT NON-EVENTS, THAT IS TO
    SAY THAT ALL NON-EVENT PROCEDURE CODE ACCOUNTS ARE KICKED OUT
    
    ########################################################################
    */
    
    DECLARE @NONEVENTPROC TABLE (
    ID INT NOT NULL PRIMARY KEY,
    [CPT CODE] VARCHAR(5)
    )
    
    INSERT INTO @NONEVENTPROC(ID, [CPT CODE])
    VALUES
    (1,'00.10'), (2,'00.15'), (3,'17.70'), (4,'92.30'),
    (5,'92.31'), (6,'92.32'), (7,'92.33'), (8,'92.39'),
    (9,'99.25'), (10,'99.28')
    ;
    
    SELECT CODE.pt_id, CODE.proc_cd
    
    FROM smsmir.mir_sproc CODE
    LEFT JOIN @NONEVENTPROC                     NOCD
    ON CODE.proc_Cd = NOCD.[CPT CODE]
    
    WHERE Pt_id BETWEEN '000010000000' AND '0000299999999'
    AND proc_Eff_Dtime > '2014-01-01'
    AND NOCD.[CPT CODE] IS NULL
    AND CODE.proc_cd <> 'CONSULT'
    
Finally we need a method of identifying those discharges that are acceptable: (This is done)
Need to make an indexed table from this just like non-events and globally excluded

    /*
    #######################################################################
    
    DISCHARGES THAT ARE OK
    
    #######################################################################
    */
    DECLARE @PT_ACCT_TYPE     VARCHAR;
    DECLARE @VISIT_ID         VARCHAR(8);
    
    SET @PT_ACCT_TYPE     = 'I';
    SET @VISIT_ID         = '20000000';
    
    SELECT *
    
    FROM smsdss.BMH_PLM_PtAcct_V
    
    WHERE dsch_disp IN ('AHR', 'ATW')
    AND Plm_Pt_Acct_Type = @PT_ACCT_TYPE
    AND PtNo_Num < @VISIT_ID
    
All of the above queries will help in identifying those admissions/discharges that are ok to use in determining if a readmission was a potentially preventable one. The logic will get applied in later queries.


----------


## Creating a Readmits View for Chains 
(This is done) 
Need to now make it an update-able indexed table

In order to see what admission is the readmit id number, we create a view that then gets `LEFT OUTER JOIN`'ed onto a recursive `CTE` that will in one row, show the initial encounter and the readmission encounter. This view is created as follows:

    /*
    ########################################################################
    
    CREATE A READMISSIONS VIEW TABLE THAT WILL GET USED TO CALCULATE
    CHAIN LENGTH AND CHAIN COUNTS
    
    ########################################################################
    */
    USE [SMSPHDSSS0X0]
    GO
    
    /****** 
    
    Object:  View [smsdss].[vReadmits] Script Date: 06/24/2014 10:55:12 
    
    ******/
    ALTER VIEW [smsdss].[vReadmits]
    AS
    SELECT T.Pt_No                 -- The Visit ID
    , T.Med_Rec_No                 -- Medical Record Number
    , MIN(R.Adm_Date) ReadmittedDT -- The Readmission Date
    , MIN(R.[Pt_NO]) NextVisitID   -- The Readmission Visit ID
    
    -- This will get a count of how many times someone was a 30 Day Readmit
    , SUM(CASE
    		WHEN R.Adm_Date <= DATEADD(D, 30, ISNULL(T.Dsch_Date, R.Adm_Date))
    		THEN 1
    		ELSE 0
    		END
    	  ) READMITNEXT30
    
    FROM smsdss.BMH_PLM_PtAcct_V          T
        LEFT JOIN smsdss.BMH_PLM_PtAcct_V R
        ON T.Med_Rec_No = R.Med_Rec_No
        AND T.Pt_No < R.Pt_No
        AND R.Plm_Pt_Acct_Type = 'I'
        AND R.Pt_No < '20000000'
    
    WHERE T.Plm_Pt_Acct_Type = 'I'
        AND T.Pt_No < '20000000'
    
    GROUP BY T.Pt_No, T.Med_Rec_No
    
    
    GO
    


Now that the view is created we can use the Recursive Common Table Expression to get the readmission daisy chain length, chain counts and discharge dispositions along with assigned APR-DRG numbers.


----------


## PPR Daisy Chains - Recursive CTE

(This is done)
Need to make this an indexed update-able table

We want to know how many times someone was a 30 day readmit, along with how many times someone was a 30 day readmit inside of a daisy chain, and how many times they were in a daisy chain. This query will not filter out any of the exclusionary details but the views and filters can be put inplace to do so.

    /*
    #######################################################################
    
    THIS QUERY WILL MAKE USE OF THE VIEW THAT WAS CREATED BY THE QUERY
    "CREATE READMIT VIEW.sql"
    
    THIS QUERY MAKES USE OF A COUPLE OF RECURSIVE CTE'S IN ORDER TO OBTAIN
    THE DAISY CHAIN COUNT AND THE COUNT OF CHAINS
    
    #######################################################################
    */
    
    -- CREATE A TABLE WHERE INITIAL ENCOUNTERS WILL BE STORED IN ORDER TO 
    -- QUERY LATER ON
    DECLARE @EVENTS TABLE (
        -- Every visit gets an eventID, think of it as another unique key
    	  EVENTID   INT IDENTITY(1,1) PRIMARY KEY
    	, EVENTDATE DATE        -- Admit Date
    	, PERSONID  VARCHAR(20) -- MRN
    	, VISIT     VARCHAR(20) -- Encounter / Visit ID
    	, DSCH      DATE        -- 
    );
    
    -- THIS COMMON TABLE EXPRESSION IS USED TO POPULATE THE EVENTS TABLE
    WITH CTE AS (
    	SELECT Adm_Date -- Date of admission
    	, Med_Rec_No    -- MRN
    	, Pt_No         -- Encounter / Visit ID --PTNO_NUM CHANGE BACK TO
    	, Dsch_Date     -- Discharge Date
    
    	FROM smsdss.BMH_PLM_PTACCT_V -- Your table here
    
    	WHERE Plm_Pt_Acct_Type = 'I' -- Only want inpatients
    	AND PtNo_Num < '20000000'    -- Only want inpatients
    	--AND Dsch_Date >= '2004-01-01'
    	--AND Dsch_Date < GETDATE()
    )
    -- INSERTING THE COMMON TABLE EXPRESSION RESULTS INTO THE EVENTS TABLE
    INSERT INTO @EVENTS
    SELECT C1.Adm_Date
    , C1.Med_Rec_No
    , C1.Pt_No --
    , C1.Dsch_Date
    
    FROM CTE C1
    
    --SELECT * FROM dbo.EVENTS ** You can uncomment this to see the output
    
    -- This table will capture all the following information
    DECLARE @EventsWithNum TABLE (
    	  EventID   INT                    -- A second unique visit key
    	, EventDate DATE                   -- Admit date
    	, PersonID  VARCHAR(20)            -- MRN
    	, VISIT     VARCHAR(20)            -- Encounter / Visit ID
    	, DSCH      DATE                   -- Discharge Date
    	, EventNum  INT                    -- 30 Day Readmit Number:
    	                                   --  (How many 30day RA's)
    	, PRIMARY KEY (EventNum, PersonID) -- Complex Index Key
    );
    INSERT @EventsWithNum
    SELECT crt.EVENTID
    , crt.EVENTDATE
    , crt.PERSONID
    , crt.VISIT
    , crt.DSCH
    , ROW_NUMBER() OVER(
    					PARTITION BY crt.PERSONID
    					ORDER BY crt.EVENTDATE
    					, CRT.EVENTID
    					) AS EventNum
    
    FROM @EVENTS crt
    WHERE crt.PERSONID IS NOT NULL -- We don't want NULL Encounter ID's
    ;
    
    --SELECT * FROM @EventsWithNum ** Uncomment to see intermediate results
    
    -- Another Common Table Expression to get the Sequential Events and counts
    WITH CountingSequentialEvents AS (
    	SELECT crt.EventID
    	, crt.EventDate
    	, crt.PersonID
    	, crt.VISIT
    	, crt.DSCH
    	, crt.EventNum
    	, 1 AS GroupNum
    	, 1 AS GroupEventNum
    
    	FROM @EventsWithNum crt
    	
    	WHERE crt.EventNum = 1
    
    	UNION ALL
    
    	SELECT crt.EventID
    	, crt.EventDate
    	, crt.PersonID
    	, crt.VISIT
    	, crt.DSCH
    	, crt.EventNum
    	, CASE
    		WHEN DATEDIFF(DAY, prev.EventDate, crt.EventDate) <= 30
    		THEN prev.GroupNum
    		ELSE prev.GroupNum + 1
    	  END AS GroupNum
    	, CASE
    		WHEN DATEDIFF(DAY, prev.EventDate, crt.EventDate) <= 30
    		THEN prev.GroupEventNum + 1
    		ELSE 1
    	  END AS GroupEventNum
    
    	FROM @EventsWithNum                  crt
    	JOIN CountingSequentialEvents        prev
    	ON crt.PersonID = prev.PersonID
    	AND crt.EventNum = prev.EventNum + 1
    )
    SELECT x.EventID                        AS [EVENT ID]
    , x.EventDate                           AS [ADMIT DATE]
    , x.PersonID                            AS [MRN]
    , x.VISIT                               AS [VISIT ID]
    , x.DSCH                                AS [DISCHARGE DATE]
    , A.drg_no                              AS [INITIAL APR-DRG]
    , CASE
    	WHEN GE.[APR-DRG] IS NULL
    	THEN 0
    	ELSE 1
      END                                   AS [INITIAL EXCLUSION FLAG]
    , B.dsch_disp                           AS [INITIAL DISPO]
    , x.GroupEventNum                       AS [CHAIN LEN]
    , x.GroupNum                            AS [CHAIN NUMBER]
    , x.EventNum                            AS [30 DAY RA COUNT]
    , V.READMIT                             AS [READMIT VISIT ID]
    , C.drg_no                              AS [READMIT APR-DRG]
    , CASE
    	WHEN GE2.[APR-DRG] IS NULL
    	THEN 0
    	ELSE 1
      END                                   AS [RA EXCLUSION FLAG]
    , D.dsch_disp                           AS [READMIT DISPO]
    , CAST(V.[READMIT DATE] AS DATE)        AS [READMIT DATE]
    , V.INTERIM
    
    FROM CountingSequentialEvents        x
    	LEFT MERGE JOIN smsdss.vReadmits V
    	ON x.VISIT = V.[INDEX] 
    	LEFT OUTER JOIN smsmir.mir_drg   A  -- Gets APR-DRG OF INITIAL VISIT
    	ON x.VISIT = A.pt_id
    	LEFT OUTER JOIN smsmir.mir_vst   B  -- Gets Discharge Dispo OF INITIAL VISIT
    	ON A.pt_id = B.pt_id
    	LEFT OUTER JOIN smsmir.mir_drg   C  -- GET APR-DRG OF READMIT VISIT
    	ON V.READMIT = C.pt_id
    	LEFT OUTER JOIN smsmir.mir_vst   D  -- GETS DISCHARGE DISPO OF READMIT VISIT
    	ON C.pt_id = D.pt_id
    	-- GET THE GLOBALLY EXCLUDED APR-DRGS SO THAT WE CAN FILTER
    	-- INITIAL APR-DRG EXCLUSION
    	LEFT OUTER JOIN smsdss.c_ppr_apr_drg_global_exclusions GE
    	ON A.drg_no = GE.[APR-DRG]
    	-- READMIT APR-DRG EXCLUSION
    	LEFT OUTER JOIN smsdss.c_ppr_apr_drg_global_exclusions GE2
    	ON C.drg_no = GE2.[APR-DRG]
    
    -- THIS LIMITS THE DRG TYPE, IT ALSO DROPS MANY RECORDS FROM THE FINAL RESULT SET
    WHERE A.drg_type = '3'
    AND C.drg_type = '3'
    
    ORDER BY x.PersonID, x.EventDate
    
1. We may to turn this into either a view or an update-able indexed table for future phase use.

The above query will get the following information:

 1. EventID  - (a secondary primary key)
 2. EventDate  - (the date of admission)
 3. PersonID  - (Medical Record Number)
 4. VISIT - (Visit ID)
 5. DSCH - (Discharge Date)
 6. drg_no - (Initial APR-DRG)
 7. Initial Exclusion Flag - (was the APR-DRG on the exclusion list, 1/0)
 8. dsch_disp - (initial discharge disposition)
 9. GroupEventNum - (Daisy Chain length)
 10. GroupNum - (Chain number)
 11. EventNum - (The count of being a 30 day readmit)
 12. NextVisitID - (The next encoutner / visit id)
 13. c.drg_no - (Readmission APR-DRG)
 14. RA Exclusion Flag - (was the APR-DRG on the exclusion list, 1/0)
 15. D.dsch_disp - (Readmission Discharge Disposition)
 16. ReadmittedDT - (Readmission Date)
 17. Interim - (How many days between addmisions, NULL allowable)

The filtering on the APR-DRG and the discharge disposition is not done with the above query as we want to turn that itself into either an indexed table or a view that can have logic applied to it for performance purposes.

## Next Steps ##
1. Create update-able indexed tables from smsdss.vReadmits
2. Create update-able indexed table from PPR_CHAINS query
3. Create indexed table for non-event procedures
4. Write non-event procedures table just like globally excluded drg table
 
    
    